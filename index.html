<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link rel="stylesheet" href="css/bootstrap.min.css"/>
        <title>JavaScript Compiler</title>
    </head>
    <body onload="init();">
        <nav class="navbar navbar-expand-lg navbar-light bg-primary">
            <h1>Liam's JavaScript Compiler</h1>
        </nav>
        <div class="container">
            <label for="form1">Source Code:</label>
            <br>
            <textarea type="text" id="input" rows="10" cols="40"></textarea>   
            <br>
            <button type="button" class="btn btn-primary btn-sm" id="btnCompile" onclick="btnCompile_click();">Compile</button>        
            <br>
            <label for="form2">Output:</label>        
            <br>
            <textarea type="text" id="output" rows="10" cols="40"></textarea>
        </div>
        <script type="text/javascript" src="scripts/lexer.js"></script>
        <script type="text/javascript" src="scripts/utils.js"></script>
        <script type="text/javascript">
            // These are the global variables
            var tokens = "";
            var tokenIndex = 0;
            var currentToken = "";
            var errorCount = 0;
            var EOF = "$";

            function init() {
                // Clear the output box when loading in
                document.getElementById("output").value = "";
                // Set the values for our global variables
                tokens = "";
                tokenIndex = 0;
                currentToken = ' ';
                errorCount = 0;
            }

            function btnCompile_click() {
                // User clicks compile button between
                // the text areas.
                init();
                putMessage("Compilation Started");
                // Take the tokens from the lexer
                tokens = lex();
                putMessage("Lex returned [" + tokens + "]");
                // now parse.
                parse();
            }

            function putMessage(msg) {
                document.getElementById("output").value += msg + "\n";
            }

            function parse() {
                putMessage("Parsing [" + tokens + "]");
                // Grab the next token.
                currentToken = getNextToken();
                // A valid parse derives the G(oal) production, so begin there.
                parseG();
                // Report the results.
                putMessage("Parsing found " + errorCount + " error(s).");        
            }

            function parseG() {
                // A G(oal) production can only be an E(xpression), so parse the E production.
                parseE();
            }

            function parseE() {
                // All E productions begin with a digit, so make sure that we have one.
                checkToken("digit");
                // Look ahead 1 char (which is now in currentToken because checkToken 
                // consumes another one) and see which E production to follow.
                if (currentToken != EOF) {
                    // We're not done, we we expect to have an op.
                    checkToken("op");
                    parseE();
                } 
                else {
                    // There is nothing else in the token stream, 
                    // and that's cool since E --> digit is valid.
                    putMessage("EOF reached");
                }
            }

            function checkToken(expectedKind) {
                // Validate that we have the expected token kind and et the next token.
                switch(expectedKind) {
                    case "digit":   putMessage("Expecting a digit");
                            if (currentToken=="0" || currentToken=="1" || currentToken=="2" || 
                                currentToken=="3" || currentToken=="4" || currentToken=="5" || 
                                currentToken=="6" || currentToken=="7" || currentToken=="8" || 
                                currentToken=="9") {
                                putMessage("Got a digit!");
                            }
                            else {
                                errorCount++;
                                putMessage("NOT a digit.  Error at position " + tokenIndex + ".");
                            }
                            break;
                    case "op":      putMessage("Expecting an operator");
                            if (currentToken=="+" || currentToken=="-") {
                            putMessage("Got an operator!");
                            }
                            else {
                                errorCount++;
                                putMessage("NOT an operator.  Error at position " + tokenIndex + ".");
                            }
                            break;
                    default:        putMessage("Parse Error: Invalid Token Type at position " + tokenIndex + ".");
                            break;			
                }
                // Consume another token, having just checked this one, because that 
                // will allow the code to see what's coming next... a sort of "look-ahead".
                currentToken = getNextToken();
            }

            function getNextToken() {
                var thisToken = EOF;    // Let's assume that we're at the EOF.
                if (tokenIndex < tokens.length) {
                    // If we're not at EOF, then return the next token in the stream and advance the index.
                    thisToken = tokens[tokenIndex];
                    putMessage("Current token:" + thisToken);
                    tokenIndex++;
                }
                return thisToken;
            }
        </script>
    </body>
</html>